<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BaseImporter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Integration Import</a> &gt; <a href="index.source.html" class="el_package">org.dynamoframework.importer.impl</a> &gt; <span class="el_source">BaseImporter.java</span></div><h1>BaseImporter.java</h1><pre class="source lang-java linenums">package org.dynamoframework.importer.impl;

/*-
 * #%L
 * Dynamo Framework
 * %%
 * Copyright (C) 2014 - 2024 Open Circle Solutions
 * %%
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */

import org.apache.commons.lang3.StringUtils;
import org.dynamoframework.exception.OCSImportException;
import org.dynamoframework.importer.ImportField;
import org.dynamoframework.importer.dto.AbstractDTO;
import org.dynamoframework.utils.ClassUtils;
import org.dynamoframework.utils.NumberUtils;
import org.springframework.beans.BeanUtils;

import java.beans.PropertyDescriptor;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDate;

import static java.lang.String.format;

/**
 * Base class for smart upload functionality
 *
 * @param &lt;R&gt; the type of a single row
 * @param &lt;U&gt; the type of a single cell or field
 * @author bas.rutten
 */
<span class="fc" id="L45">public abstract class BaseImporter&lt;R, U&gt; {</span>

	private static final double PERCENTAGE_FACTOR = 100.;

	/**
	 * Counts the number of rows in the input. This method will count all rows,
	 * including the header, and will not check if any of the rows are valid
	 *
	 * @param bytes      the byte representation of the input file
	 * @param sheetIndex the index of the sheet (if appropriate)
	 * @return the number of rows
	 */
	public abstract int countRows(byte[] bytes, int sheetIndex);

	/**
	 * Retrieves a boolean value from the input and falls back to a default if the
	 * value is empty or not defined
	 *
	 * @param unit  the unit of data value to process (string, Excel cell etc)
	 * @param field the field definition
	 * @return the Boolean value
	 */
	protected abstract Boolean getBooleanValueWithDefault(U unit, ImportField field);

	/**
	 * Retrieves a date value from the input and falls back to a default if the
	 * value is empty or not defined
	 *
	 * @param unit  the unit of data to process
	 * @param field the field definition
	 * @return the LocalDate value
	 */
	protected abstract LocalDate getDateValueWithDefault(U unit, ImportField field);

	/**
	 * Retrieves a value from a unit of data
	 *
	 * @param d     the property descriptor that tells the process the type of the
	 *              value to retrieve
	 * @param unit  the unit of data to process
	 * @param field the field definition
	 * @return the field value
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	protected Object getFieldValue(PropertyDescriptor d, U unit, ImportField field) {
<span class="fc" id="L90">		Object obj = null;</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">		if (String.class.equals(d.getPropertyType())) {</span>
<span class="fc" id="L92">			String value = getStringValueWithDefault(unit, field);</span>
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">			if (value != null) {</span>
<span class="fc" id="L94">				value = value.trim();</span>
			}
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">			obj = StringUtils.isEmpty(value) ? null : value;</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">		} else if (d.getPropertyType().isEnum()) {</span>
<span class="fc" id="L98">			String value = getStringValueWithDefault(unit, field);</span>
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">			if (value != null) {</span>
<span class="fc" id="L100">				value = value.trim();</span>
				try {
					@SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L103">					Class&lt;? extends Enum&gt; enumType = d.getPropertyType().asSubclass(Enum.class);</span>
<span class="fc" id="L104">					obj = Enum.valueOf(enumType, value.toUpperCase());</span>
<span class="nc" id="L105">				} catch (IllegalArgumentException ex) {</span>
<span class="nc" id="L106">					throw new OCSImportException(&quot;Value &quot; + value + &quot; cannot be translated to an enumeration value&quot;,</span>
						ex);
<span class="fc" id="L108">				}</span>
			}
<span class="fc bfc" id="L110" title="All 2 branches covered.">		} else if (isNumeric(d.getPropertyType())) {</span>
			// numeric field
<span class="fc" id="L112">			Double value = getNumericValueWithDefault(unit, field);</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">			if (value != null) {</span>

				// if the field represents a percentage but it is
				// received as a
				// fraction, we multiply it by 100
<span class="fc bfc" id="L118" title="All 4 branches covered.">				if (field.percentage() &amp;&amp; isPercentageCorrectionSupported()) {</span>
<span class="fc" id="L119">					value = PERCENTAGE_FACTOR * value;</span>
				}

				// illegal negative value
<span class="fc bfc" id="L123" title="All 4 branches covered.">				if (field.cannotBeNegative() &amp;&amp; value &lt; 0.0) {</span>
<span class="fc" id="L124">					throw new OCSImportException(&quot;Negative value &quot; + value + &quot; found for field '&quot; + d.getName() + &quot;'&quot;);</span>
				}

				// round to the nearest integer, then use intValue() or longValue()
<span class="fc" id="L128">				BigDecimal rounded = BigDecimal.valueOf(value).setScale(0, RoundingMode.HALF_UP);</span>
<span class="fc" id="L129">				Class&lt;?&gt; pType = d.getPropertyType();</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">				if (NumberUtils.isInteger(pType)) {</span>
<span class="fc" id="L131">					obj = rounded.intValue();</span>
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">				} else if (NumberUtils.isLong(pType)) {</span>
<span class="nc" id="L133">					obj = rounded.longValue();</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">				} else if (NumberUtils.isFloat(pType)) {</span>
<span class="nc" id="L135">					obj = value.floatValue();</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">				} else if (NumberUtils.isDouble(pType)) {</span>
<span class="fc" id="L137">					obj = value;</span>
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">				} else if (BigDecimal.class.equals(pType)) {</span>
<span class="fc" id="L139">					obj = BigDecimal.valueOf(value);</span>
				}
			}
<span class="fc bfc" id="L142" title="All 2 branches covered.">		} else if (Boolean.class.isAssignableFrom(d.getPropertyType())) {</span>
<span class="fc" id="L143">			obj = getBooleanValueWithDefault(unit, field);</span>
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">		} else if (LocalDate.class.isAssignableFrom(d.getPropertyType())) {</span>
<span class="fc" id="L145">			obj = getDateValueWithDefault(unit, field);</span>
		}
<span class="fc" id="L147">		return obj;</span>
	}

	/**
	 * Retrieves a numeric value from an input unit and falls back to a default if
	 * the value is empty or not defined
	 *
	 * @param unit  the input unit
	 * @param field the field definition
	 * @return the Double value
	 */
	protected abstract Double getNumericValueWithDefault(U unit, ImportField field);

	/**
	 * Retrieves a string from the input and falls back to a default if the value is
	 * empty or not defined
	 *
	 * @param unit  the input unit
	 * @param field the field definition
	 * @return the String value
	 */
	protected abstract String getStringValueWithDefault(U unit, ImportField field);

	/**
	 * Retrieves a unit (a single cell or field) from a row
	 *
	 * @param row   the row
	 * @param field the field definition
	 * @return the retrieved unit
	 */
	protected abstract U getUnit(R row, ImportField field);

	/**
	 * Check if the class is a numeric class
	 *
	 * @param clazz the class to check
	 * @return true if the value is numeric, false otherwise
	 */
	private boolean isNumeric(Class&lt;?&gt; clazz) {
<span class="pc bpc" id="L186" title="1 of 6 branches missed.">		return Number.class.isAssignableFrom(clazz) || int.class.equals(clazz) || long.class.equals(clazz)</span>
<span class="pc bpc" id="L187" title="2 of 4 branches missed.">			|| double.class.equals(clazz) || float.class.equals(clazz);</span>
	}

	/**
	 * Indicates whether fraction values are automatically converted to percentages
	 *
	 * @return true if this is the case, false otherwise
	 */
	public abstract boolean isPercentageCorrectionSupported();

	/**
	 * Checks whether a field index is within the range of available columns
	 *
	 * @param row   the row to check
	 * @param field the field definition
	 * @return true if this is the case, false otherwise
	 */
	protected abstract boolean isWithinRange(R row, ImportField field);

	/**
	 * Processes a single row from the input and turns it into an object
	 *
	 * @param rowNum the row number
	 * @param row    the row
	 * @param clazz  the class of the object that must be created
	 * @return
	 */
	public &lt;T extends AbstractDTO&gt; T processRow(int rowNum, R row, Class&lt;T&gt; clazz) {
<span class="fc" id="L215">		T dto = ClassUtils.instantiateClass(clazz);</span>
<span class="fc" id="L216">		dto.setRowNum(rowNum);</span>

<span class="fc" id="L218">		PropertyDescriptor[] descriptors = BeanUtils.getPropertyDescriptors(clazz);</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">		for (PropertyDescriptor descriptor : descriptors) {</span>
<span class="fc" id="L220">			ImportField field = ClassUtils.getAnnotation(clazz, descriptor.getName(), ImportField.class);</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">			if (field != null) {</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">				if (isWithinRange(row, field)) {</span>
<span class="fc" id="L223">					U unit = getUnit(row, field);</span>

<span class="fc" id="L225">					Object obj = getFieldValue(descriptor, unit, field);</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">					if (obj != null) {</span>
<span class="fc" id="L227">						ClassUtils.setFieldValue(dto, descriptor.getName(), obj);</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">					} else if (field.required()) {</span>
						// a required value is missing!
<span class="fc" id="L230">						throw new OCSImportException(</span>
<span class="fc" id="L231">							format(&quot;Required value for field '%s' is missing&quot;, descriptor.getName()));</span>
					}
<span class="fc" id="L233">				} else {</span>
<span class="fc" id="L234">					throw new OCSImportException(format(&quot;Row %d doesn't have enough columns&quot;, rowNum));</span>
				}
			}
		}
<span class="fc" id="L238">		return dto;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>